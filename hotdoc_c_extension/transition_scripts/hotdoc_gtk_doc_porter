#!/usr/bin/python
# -*- coding: utf-8 -*-
#
# Copyright © 2016 Mathieu Duponchelle <mathieu.duponchelle@opencreed.com>
# Copyright © 2016 Collabora Ltd
#
# This library is free software; you can redistribute it and/or modify it under
# the terms of the GNU Lesser General Public License as published by the Free
# Software Foundation; either version 2.1 of the License, or (at your option)
# any later version.
#
# This library is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more
# details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with this library.  If not, see <http://www.gnu.org/licenses/>.

import os
import sys
import urllib
import argparse
import urlparse
import shutil
import subprocess
import io
import cgi

from copy import deepcopy

import yaml

from lxml import etree

from hotdoc.utils.patcher import Patcher
from hotdoc.utils.utils import OrderedSet, recursive_overwrite
from hotdoc.core.symbols import *
from hotdoc.core.config import ConfigParser
from hotdoc.core.doc_repo import DocRepo
from hotdoc.core.exceptions import HotdocException
from hotdoc.core.doc_database import DocDatabase
from hotdoc.core.links import Link
from hotdoc.parsers.gtk_doc_parser import GtkDocStringFormatter
from hotdoc_gi_extension.gi_extension import GIExtension
from hotdoc.utils.loggable import warn, info, debug, Logger

class SymbolNotFoundException(HotdocException):
    pass

Logger.register_warning_code('section-symbol-not-found',
    SymbolNotFoundException, 'gtk-doc-port')

# Some useful symbols

MD_OUTPUT_PATH = 'hotdoc_markdown'

def which(program):
    import os
    def is_exe(fpath):
        return os.path.isfile(fpath) and os.access(fpath, os.X_OK)

    fpath, fname = os.path.split(program)
    if fpath:
        if is_exe(program):
            return program
    else:
        for path in os.environ["PATH"].split(os.pathsep):
            path = path.strip('"')
            exe_file = os.path.join(path, program)
            if is_exe(exe_file):
                return exe_file

    return None

def require_program(program):
    if which(program) is None:
        print "Checking for %s: no" % program
        print "Please install %s" % program
        sys.exit(1)
    print "Checking for %s: yes" % program

def require_path(path):
    if not os.path.isfile(path):
        print "%s is not a valid path" % path
        print "Please correct it, exiting"
        sys.exit(1)

def check_pandoc():
    require_program('pandoc')
    oformats = ['commonmark', 'markdown_github', 'markdown']
    pandoc_help = subprocess.check_output(['pandoc', '-h'])

    print "Checking pandoc output formats in preference order"

    found = False

    for oformat in oformats:
        if oformat in pandoc_help:
            res = 'yes'
            found = True
        else:
            res = 'no'

        print "Checking pandoc's '%s' output format: %s" % (oformat, res)

        if found:
            break

    if not found:
        print "No format found, please install a newer pandoc"
        sys.exit(1)

    return oformat

def stripped_basename(path):
    bname = os.path.basename(path)
    return os.path.splitext(bname)[0]

def quiet_call(cmd):
    with open(os.devnull, 'w') as shutup:
        return_code = subprocess.call(cmd, stdout=shutup, stderr=shutup)
    return return_code

def is_version_controlled(dir_, path):
    cwd = os.getcwd()
    os.chdir(dir_)
    result = quiet_call(['git', 'ls-files', '--error-unmatch', path])
    os.chdir(cwd)
    return result == 0

MD_FORMAT = check_pandoc()
require_program('git')


class DocRepoMonitor(object):
    def __init__(self):
        self.section_comments = {}
        self.class_comments = {}

    def build(self, args):
        DocDatabase.comment_added_signal.connect(self.__comment_added)
        self.doc_repo = DocRepo()
        self.doc_repo.setup(args)
        self.naive_pages = {}
        for name, page in self.doc_repo.doc_tree.get_pages().items():
            bname = os.path.basename(name)

            if not bname.startswith('gen-'):
                continue

            if bname == 'gen-gi-extension-index.markdown':
                continue

            bname = bname[4:]
            stripped = os.path.splitext(bname)[0]
            self.naive_pages[stripped] = page

    def sort_section_comments(self, sections):
        actual_section_comments = {}
        for name, section in sections.items():
            section_comment = self.section_comments.get(name)
            if section_comment is None:
                continue

            sym = self.doc_repo.doc_database.get_symbol(section.title or name)
            if sym and type(sym) is StructSymbol:
                class_name = u'%s::%s' % (sym.unique_name, sym.unique_name)
                class_sym = self.doc_repo.doc_database.get_symbol(class_name)
                if class_sym:
                    new_name = class_name + ':'
                    section_comment.raw_comment = \
                        section_comment.raw_comment.replace(section_comment.name,
                            new_name)
                    self.class_comments[new_name] = section_comment
                    section.comment = None
                else:
                    actual_section_comments[name] = section_comment
                    section_comment.raw_comment = ''
            else:
                actual_section_comments[name] = section_comment
                section_comment.raw_comment = ''

        self.section_comments = actual_section_comments

    def __comment_added(self, doc_db, comment):
        if comment.name.startswith('SECTION'):
            name = comment.name[len('SECTION'):].lstrip(': ').strip()
            self.section_comments[name] = comment

def db_to_md (content):
    with open ("tmpfile", 'w') as f:
        f.write (content)
    cmd = ['pandoc', '-s', '-f', 'docbook', '-t', MD_FORMAT]
    cmd.append ("tmpfile")
    converted = subprocess.check_output (cmd)
    os.unlink ('tmpfile')
    return converted

class DTDResolver(etree.Resolver):
    def __init__(self, paths):
        self.urls = {}
        for p in paths or []:
            for f in os.listdir(p):
                url = os.path.join(p, f)
                if os.path.isfile(url):
                    self.urls[f] = url

    def resolve(self, url, id, context):
        comps = urlparse.urlparse(url)
        if not comps.scheme:
            bname = os.path.basename(url)
            my_url = self.urls.get(bname)
            if my_url:
                return self.resolve_filename(my_url, context)
        return etree.Resolver.resolve(self, url, id, context)

def get_free_md_path(md_paths, name):
    path = os.path.join (MD_OUTPUT_PATH, name + ".markdown")

    n = 0
    while path in md_paths:
        n += 1
        path = os.path.join (MD_OUTPUT_PATH, name + '_' * n + ".markdown")

    md_paths[name] = path

    return path

def replace_with_link(node, md_name, label):
    parent = node.getparent()
    new_node = etree.Element('sect4')
    title = etree.Element('title')
    link = etree.Element('ulink', attrib={'url': md_name})
    link.text = label
    title.append(link)
    new_node.append(title)
    parent.replace(node, new_node)

def dump_gi_index(page, standalones, md_paths):
    md_content = '---\n'
    md_content += 'short-description: GObject API Reference Manual\n'
    md_content += '...\n\n'
    md_content += '# API Reference\n\n'

    parent = standalones[0].getparent()
    parent.remove(standalones[0])

    if len(standalones) == 1:
        db_content = etree.tostring(standalones[0])
        md_content += db_to_md (db_content)
    else:
        sectnum = 0
        for standalone in standalones:
            parent = standalone.getparent()
            if parent is not None:
                parent.remove(standalone)

            tnode = standalone.find('./title')
            if tnode is not None:
                title = "".join([x for x in tnode.itertext()])
            else:
                sectnum += 1
                title = "Section %d" % sectnum
            db_content = etree.tostring(standalone)
            href = title
            md_path = urllib.unquote(get_free_md_path(md_paths, href))
            sub_md_content = db_to_md (db_content)
            with open(md_path, 'w') as f:
                f.write(sub_md_content)

    md_path = os.path.join(MD_OUTPUT_PATH, 'gi-index.markdown')
    with open(md_path, 'w') as f:
        f.write (md_content)

NSMAP = {'xml': 'http://www.w3.org/XML/1998/namespace'}

def collect_xrefs(doc_repo, filename, root):
    id_nodes = root.xpath('.//*[@id]')
    id_nodes.extend(root.xpath('.//*[@xml:id]', namespaces=NSMAP))
    if 'id' in root.attrib or '{%s}id' % NSMAP['xml'] in root.attrib:
        id_nodes.append(root)

    for node in id_nodes:
        title = node.find('.//refentrytitle')
        if title is None:
            title = node.find('.//{http://docbook.org/ns/docbook}refentrytitle')
        if title is None:
            title = node.find('.//title')
        if title is None:
            title = node.find('.//{http://docbook.org/ns/docbook}title')

        id_ = node.attrib.get('id') or node.attrib.get('{%s}id' % NSMAP['xml'])

        if title is None:
            title = id_
        else:
            title = "".join([x for x in title.itertext()]).strip()

        ref = stripped_basename(filename) + '.markdown'
        if node != root:
            ref += '#' + title.lower().replace(' ', '-')
        link = Link(ref, title, id_)
        doc_repo.link_resolver.add_link(link)

def translate_docbook(filename, resolver, md_paths, new_name, doc_repo, files_to_render, parent_page):
    with open(filename, 'r') as _:
        xincluded = _.read()

    subpages = {}

    dir_ = os.path.dirname(filename)

    parser = etree.XMLParser(load_dtd=True, recover=True)
    parser.resolvers.add(resolver)
    root = etree.parse(filename, parser=parser).getroot()

    if root is None:
        return

    NSMAP.update(root.nsmap)
    NSMAP.pop(None, None)

    for error in parser.error_log:
        print error

    if parser.error_log:
        print "Continuing despite the error"

    includes = root.findall('.//{%s}include' % NSMAP['xi'])

    standalones = OrderedSet()

    for node in includes:
        href = node.attrib.get('href')
        if href is None:
            continue

        bname = stripped_basename(href)
        parent = node.getparent()

        if bname == 'annotation-glossary' or bname.startswith('api-index') or \
                bname.startswith('tree_index'):
            parent.remove(node)
            continue

        md_path = get_free_md_path(md_paths, bname)
        md_path = os.path.basename(md_path)
        parent.remove(node)

        if is_version_controlled(dir_, href):
            subpages[bname] = os.path.join(dir_, href)
        elif new_name == 'index':
            grandparent = parent.getparent()
            while grandparent is not None and grandparent not in standalones:
                grandparent = grandparent.getparent()

            standalones.add(parent)

    metadict = {}

    refnamediv = root.find('./refnamediv')
    bookinfo = root.find('./bookinfo')
    md_content = ''
    if bookinfo is not None:
        sect1 = etree.Element('sect1')
        for elem in bookinfo:
            sect1.append(deepcopy(elem))
        root.replace(bookinfo, sect1)
    elif refnamediv is not None:
        root.remove(refnamediv)
        refname = refnamediv.find('./refname')
        if refname is not None:
            metadict['title'] = "".join([x for x in refname.itertext()]).strip()
        refpurpose = refnamediv.find('./refpurpose')
        if refpurpose is not None:
            short =  "".join([x for x in refpurpose.itertext()]).strip()
            metadict['short-description'] = short.replace('\n', '')

    if metadict:
        md_content += '---\n'
        md_content += yaml.dump(metadict, default_flow_style=False)
        md_content += '...\n\n'


    collect_xrefs(doc_repo, filename, root)


    files_to_render[md_paths[new_name]] = (root, md_content)
    parent_page['url'] = md_paths[new_name]
    parent_page['subpages'] = []

    if standalones:
        cpage = {'url': 'gi-index',
                 'subpages': []}
        parent_page['subpages'].append(cpage)
        dump_gi_index(cpage, list(standalones), md_paths)

    for new_name, filename in subpages.items():
        cpage = {}
        translate_docbook(filename, resolver, md_paths, new_name, doc_repo, files_to_render, cpage)
        parent_page['subpages'].append(cpage)

class Section(object):
    def __init__(self, node):
        self.node = node
        self.comment = None
        self.ofile = None
        self.title = None
        self.symbols = set()
        if node is not None:
            self.ofile = unicode(node.find('FILE').text)
            tnode = node.find('TITLE')
            if tnode is not None:
                self.title = tnode.text
            else:
                self.title = None
            symbols = node.getchildren()[-1].tail.split("\n")
            self.symbols = set([s for s in symbols if s])


def parse_section_file(sections_path, section_comments):
    here = os.path.dirname(__file__)
    trans_shscript_path = os.path.join(here, 'translate_sections.sh')
    cmd = [trans_shscript_path, sections_path, 'hotdoc-tmp-sections.txt']
    subprocess.check_call(cmd)
    sections_root = etree.parse('hotdoc-tmp-sections.txt').getroot()
    sections = {}
    for section in sections_root.findall ('.//SECTION'):
        section = Section(section)
        section.comment = section_comments.get(section.ofile)
        sections[section.ofile] = section

    os.unlink('hotdoc-tmp-sections.txt')
    return sections

def translate(docstring):
    formatter = GtkDocStringFormatter()
    docstring = cgi.escape(docstring)
    return formatter.translate(docstring, None, 'markdown')

def write_symbols(monitor, section):
    not_found = 0
    found = 0
    opath = os.path.join(MD_OUTPUT_PATH, section.ofile + '.markdown')
    contents = u''

    with io.open(opath, 'w', encoding='utf-8') as f:
        metadict = {}
        metadict['symbols'] = []
        if section.comment:
            if section.comment.title:
                metadict['title'] = cgi.escape(section.comment.title)
            elif section.title:
                metadict['title'] = cgi.escape(section.title)
            if section.comment.short_description:
                short = translate(section.comment.short_description)
                metadict['short-description'] = short.replace('\n', '')
            if section.comment.description:
                desc = section.comment.description.split('\n')
                for i, line in enumerate(desc):
                    desc[i] = line.strip()
                contents = u'%s\n' % translate('\n'.join(desc))
        for symbol in section.symbols:
            sym = monitor.doc_repo.doc_database.get_symbol(symbol)
            if sym is None:
                debug("Warning, the symbol %s referenced in the "
                "section file under the %s output file could not "
                "be found" % (symbol, section.ofile), 'gtk-doc-port')
                not_found += 1
            else:
                metadict['symbols'].append(symbol)
                found += 1
        f.write(u'---\n')
        f.write(unicode(yaml.dump(metadict, default_flow_style=False)))
        f.write(u'...\n\n')
        f.write(contents)
    
    return not_found

def translate_sections(monitor, sections):
    not_found = 0
    n_symbols = 0
    gi_subpages = []
    for sname, section in sections.items():
        not_found += write_symbols(monitor, section)
        n_symbols += len(section.symbols)
        gi_subpages.append(section.ofile + '.markdown')

    if not_found:
        warn('section-symbol-not-found',
            "%d symbols out of %d could not be found, please verify that "
            "the list of input sources is complete. "
            "Note that some symbols might be hidden "
            "by the preprocessor. "
            "Rerun this tool with HOTDOC_DEBUG=2 to see the full list "
            "of missing symbols." % (not_found, n_symbols))

    return gi_subpages

def patch_comments(patcher, comments):
    if not comments:
        return

    for comment in comments:
        patcher.patch(comment.filename, comment.lineno - 1,
                comment.endlineno, comment.raw_comment)
        if comment.raw_comment == '':
            for other_comment in comments:
                if (other_comment.filename == comment.filename and
                        other_comment.lineno > comment.endlineno):
                    removed = comment.endlineno - comment.lineno
                    other_comment.lineno -= removed
                    other_comment.endlineno -= removed

def sections_from_naive_pages(monitor):
    sections = {}
    for nname, npage in monitor.doc_repo.doc_tree.get_pages().items():
        if not \
            npage.source_file.startswith(monitor.doc_repo.get_generated_doc_folder()):
            continue
        section = Section(None)
        relpath = os.path.relpath(nname,
            monitor.doc_repo.get_generated_doc_folder())
        if relpath == 'gen-gi-extension-index.markdown':
            continue
        dname = os.path.dirname(relpath)
        fname = os.path.basename(relpath)[4:]
        stripped = os.path.splitext(fname)[0]
        section.ofile = os.path.join(dname, fname)
        section.comment = monitor.section_comments.get(stripped)
        if section.comment:
            section.title = section.comment.title
        if not section.title:
            section.title = stripped
        sections[stripped] = section

    return sections

def dump_sitemap(page, gi_subpages, level=0):
    if not page:
        return

    with open('sitemap.txt', 'a') as _:
        _.write('\t' * level + os.path.basename(page['url']) + '\n')
        if page['url'] == 'gi-index':
            for url in gi_subpages:
                _.write('\t' * (level + 1) + url + '\n')
    for cpage in page['subpages']:
        dump_sitemap(cpage, gi_subpages, level + 1)

def render_files(files_to_render, doc_repo):
    for md_path, tup in files_to_render.items():
        root, md_content = tup
        links = root.findall('.//link')
        links.extend(root.findall('.//xref'))
        links.extend(root.findall('.//{http://docbook.org/ns/docbook}link'))
        links.extend(root.findall('.//{http://docbook.org/ns/docbook}xref'))

        for link_node in links:
            linkend = link_node.attrib.get('linkend')
            if linkend is None:
                continue

            sym_name = linkend.replace('-', '_')
            if sym_name.endswith(':CAPS'):
                sym_name = sym_name[:-5]
            link = doc_repo.link_resolver.get_named_link(sym_name)
            if link is None:
                link = doc_repo.link_resolver.get_named_link(linkend)

            symbol = doc_repo.doc_database.get_symbol(sym_name)
            if link:
                if symbol:
                    link_node.attrib['url'] = link.id_
                else:
                    link_node.attrib['url'] = link.get_link()

                if link_node.tag == 'xref':
                    link_node.text = link.get_title()

                link_node.tag = 'ulink'
                continue

        md_content += db_to_md (etree.tostring(root))
        with open (md_path, 'w') as f:
            f.write (md_content)

if __name__=='__main__':
    parser = argparse.ArgumentParser()

    parser.add_argument('--section-file', action='store',
        dest='section_file', help='The path to the gtk-doc "sections file"')
    parser.add_argument('--docbook-index', action='store',
        required=True, dest='docbook_index',
        help='The path to the docbook index')
    parser.add_argument('--conf-file', action='store',
        required=True, dest='conf_file',
        help='The path to a hotdoc.json file configured for'
             'parsing the C sources of the project')
    parser.add_argument('--extra-dtd-path', action='append',
        help='Path to an extra DTD if needed, can be specified multiple times',
        dest='extra_dtd_paths')

    args = parser.parse_args()
    # Ensure we build from scratch
    for dirname in os.listdir('.'):
        if dirname.startswith('hotdoc-private'):
            shutil.rmtree(dirname)
    shutil.rmtree(MD_OUTPUT_PATH, ignore_errors=True)

    os.mkdir(MD_OUTPUT_PATH)

    require_path(args.conf_file)
    require_path(args.docbook_index)

    hdargs = ['run', '--conf-file', args.conf_file, '--gi-smart-index']
    monitor = DocRepoMonitor()
    monitor.build(hdargs)

    gi_subpages = []

    if args.section_file is not None:
        require_path(args.section_file)
        sections = parse_section_file(args.section_file,
            monitor.section_comments)
        monitor.sort_section_comments(sections)
        gi_subpages = translate_sections(monitor, sections)
    else:
        sections = sections_from_naive_pages(monitor)
        monitor.sort_section_comments(sections)
        for sname, section in sections.items():
            section_comment = monitor.section_comments.get(sname)
            if section_comment:
                full_path = os.path.join(MD_OUTPUT_PATH, section.ofile)
                dname = os.path.dirname(full_path)
                if not os.path.exists(dname):
                    os.makedirs(dname)
                    with io.open(full_path, 'w', encoding='utf-8') as f:
                        if section_comment.title:
                            f.write(u"### %s\n\n" % cgi.escape(section_comment.title))
                        elif section.title:
                            f.write(u"### %s\n\n" % cgi.escape(section.title))
                        if section_comment.short_description:
                            f.write(u'%s\n\n' %
                                translate(section_comment.short_description))
                        if section_comment.description:
                            f.write(u'%s\n\n' % translate(section_comment.description))

    resolver = DTDResolver(args.extra_dtd_paths)
    md_paths = {'gi-index': os.path.join(MD_OUTPUT_PATH, 'gi-index.markdown')}
    md_paths['index'] = os.path.join(MD_OUTPUT_PATH, 'index.markdown')

    files_to_render = {}
    sitemap_root = {}
    translate_docbook(args.docbook_index, resolver, md_paths, 'index',
        monitor.doc_repo, files_to_render, sitemap_root)

    os.unlink('sitemap.txt')
    dump_sitemap(sitemap_root, gi_subpages)

    render_files(files_to_render, monitor.doc_repo)

    patcher = Patcher()
    patch_comments(patcher, monitor.class_comments.values() +
        monitor.section_comments.values())

    extra_conf = {
        'gi_index': 'gi-index.markdown',
        'languages': ['c', 'python', 'javascript'],
        'output': 'built_doc',
        'gtk_doc_escape_html': True,
        'page_parser_escape_html': True,
        }

    ncp = ConfigParser(conf_file=args.conf_file,
        command_line_args=extra_conf)

    ncp.dump(args.conf_file)

    recursive_overwrite(MD_OUTPUT_PATH, monitor.doc_repo.get_base_doc_folder())
    shutil.rmtree(MD_OUTPUT_PATH)
